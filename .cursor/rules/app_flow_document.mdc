---
description: Apply these rules when making changes to the project
globs:
alwaysApply: true
---

Update this rule if user requested changes to the project requirement, etc.
# App Flow Document

## Onboarding and Sign-In/Sign-Up
A new user arrives at the scheduler by navigating to the `/scheduler` path within the DriveShop Rails FMS. The Rails application reverse-proxies that path and injects a short-lived JWT into the request header under `X-DriveShop-Token`. When the React frontend loads, it immediately calls the `/auth/exchange` endpoint, sending the header-injected JWT. The backend validates the token signature, expiration, and replay ID, then issues a secure HttpOnly session cookie scoped to the scheduler domain. With the session cookie established, the user’s markets and permission levels (Editor, Approver, or Viewer) are fetched and stored in memory. If a user’s session expires or the JWT is invalid, any API call returns a 401 Unauthorized, prompting the frontend to redirect back to `/scheduler` so Rails can reissue a fresh JWT. To sign out, the user clicks “Sign out of Scheduler,” which calls `POST /auth/logout` to clear the session cookie and then redirects back to the FMS logout endpoint. All authentication and password recovery flows are managed by the parent FMS, so individual users never enter credentials directly into the scheduler.

## Main Dashboard or Home Page
Upon successful sign-in, the user lands on the scheduler dashboard. The top header displays the DriveShop logo and a market selector showing offices the user can access. Below the header, a week picker defaults to the current week’s Monday start date. The central panel shows two main sections: an ingestion panel for uploading CSV files and a schedule run browser. The ingestion panel provides a dropdown of table names (vehicles, media partners, partner make ranks, loan history, current activity, or ops capacity) and an upload button. The schedule run browser lists past runs with columns for run ID, office, week, status (Draft or Published), and last updated by. A primary action button labeled “Generate Schedule” sits next to the week picker. A fixed footer or sticky bar contains quick links to Settings and Audit Log for admins. Navigation between pages occurs by clicking the CSV upload area to start ingestion, selecting a run row to view details, or tapping the Generate button to move forward into schedule creation.

## Detailed Feature Flows and Page Transitions
When the user uploads a CSV, the browser sends a multipart request to `POST /ingest/{table}`. The server validates each row against Pydantic schemas, returning a 400 error response with row-level validation messages if any errors occur. On success, the UI shows a green confirmation banner and refreshes the ingestion history list. To generate a schedule, the user picks an office and week, then clicks “Generate Schedule.” The frontend calls `POST /schedule/generate?office=XXX&week=YYYY-MM-DD`. The backend runs ETL transforms to compute availability_by_day, rolling publication rates, and cooldown flags before invoking the greedy solver. Once results return, the UI replaces the ingestion panel with an interactive week-view table. Each row shows the vehicle VIN, partner name, assigned day, total score, and colored chips for tier, cooldown, capacity, availability, and optional budget warnings. The user can sort columns by score or date, search by VIN or partner name, and filter rows by chip status or office.

Clicking a chip or row opens a modal that fetches `GET /explain/{vin}/{partner_id}/{day}`, displaying a breakdown of hard rule checks and soft preference points. If the scheduler disagrees with a recommendation, they can inline-override either the partner or the day. The app re-validates the change immediately and tags the row with an override flag in the audit log. All override actions store the old and new values along with user and timestamp in the `audit_log` table. When every assignment is confirmed, the user clicks “Publish.” This triggers `POST /schedule/publish` with the approved rows. The backend persists the final schedule to a `published_schedules` table, returns a run ID, and updates the dashboard’s run list to show the new Published entry. Clicking on any published run in the list calls `GET /schedule/{id}` to load that run’s details in the same week-view format. At any point, the user can click “Export CSV” to download the approved schedule in a clean format including VIN, partner, office, date, score, flags, approved_by, and budget status.

## Settings and Account Management
The Settings page is reachable from a gear icon in the header. Here, users see their name, email, and markets pulled from the JWT exchange. Although core profile management remains in the FMS, the scheduler Settings page allows users to toggle email notification preferences for ingestion and schedule errors. Notification settings are saved to a small preferences table in the database and control whether immediate email alerts are sent on hard failures or soft warnings. Approvers also have a link on this page to view audit trail settings, such as retention periods. A “Return to Dashboard” button brings the user back to the main scheduler flow.

## Error States and Alternate Paths
If CSV ingestion fails schema validation, the UI displays a red error panel listing up to the first five row errors, and an email alert is triggered to the Ops distribution list summarizing the validation failures. In the event schedule generation throws an exception or returns zero results, the user sees a banner with error details and a retry button. A daily digest email aggregates any soft warnings or minor ingestion issues that do not block the pipeline. When the user loses connectivity or the backend is unreachable, the app shows an offline banner and queues interaction attempts until reconnection. Attempting to perform restricted actions without the correct permission level results in a 403 Forbidden response and a modal explaining the lack of access. If the JWT exchange fails due to an expired or malformed token, the frontend redirects to `/scheduler` to force a reauthentication through Rails.

## Conclusion and Overall App Journey
A DriveShop scheduler begins by arriving under the FMS domain and automatically exchanging a Rails JWT for a secure session. From there, the user uploads CSV data to seed the Postgres database, watches for schema validation results, and then triggers weekly schedule generation. The resulting assignments appear in a responsive, filterable React table with colored rationale chips and an explain modal for each assignment. The scheduler can override recommendations inline and track all changes in an append-only audit log. Once everything is approved, the schedule is published, stored under a unique run ID, and can be retrieved later or exported as a CSV. Throughout the entire flow, email notifications and audit logging ensure visibility and accountability, while hard constraints and optimization layers guarantee feasible, high-quality scheduling outcomes every week.